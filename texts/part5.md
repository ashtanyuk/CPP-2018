## Перегрузка операций

Одной из важнейших особенностей языка С++ явяется возможность **перегрузки операторов (операций)**.

Вспомним сначала, что такое **перегрузка функций**:

**Перегрузка** - это создание функции с тем же именем, но с отличающимся списком параметров. Иными словами, перегруженные функции называются одинаково, но отличаются количеством или типами своих параметров. Благодаря этому, компилятор их отличает друг от друга в точке вызова.

Перегрузка операций позволяет разработать аналог операции для пользовательского типа в виде функции с определенным набором параметров.

Перегрузка может быть осуществлена

- в виде функции-члена класса (методом)
- в виде глобальной функции (обычной или дружественной классу)

Хороший пример задачи, в которой используется перегрузка: матрицы

```cpp
Matrix a,b,c;
...
c=a+b;
```

Для успешного использования перегрузки, надо знать и соблюдать ряд правил:

- перегружать можно все имеющиеся операции, кроме 
   - ?: - тернарный оператор;
   - :: - доступ к вложенным именам;
   - .  - доступ к полям;
   - .* - доступ к полям по указателю;
   - sizeof, typeid и операторы cast.

- нельзя придумывать свои операции, например @,+++,)( и др.
- при перегрузке нельзя изменять арность операции, ассоциативность, приоритет
- способы перегрузки унарных и бинарных операций отличаются
- хотя бы один из аргументов перегружаемых оператором должен быть пользовательского типа

- следующие операторы можно перегрузить только в качестве методов:
   - = - присваивание;
   - -> - доступ к полям по указателю;
   - () - вызов функции;
   - [] - доступ по индексу;
   - ->* - доступ к указателю-на-поле по указателю;
   - операторы конверсии и управления памятью.

- следующие операторы можно перегрузить только в виде внешних функций:
   - чтение из потока
   - запись в поток
   
### Перегрузка методом класса

#### Бинарные операции

Для перегрузки бинарных операций нужно создать метод, принимающий один аргумент - ссылку на второй аргумент операции.

```cpp
class Complex
{
   private:
     double Re,Im;
   public:
     Complex(double re,double im):Re(re),Im(im) {}
     Complex operator+(const Complex& c) {
        return Complex(Re+c.Re,Im+c.Im);
     }
};
```
Метод, перегружающий операцию сложения, называется **operator+**. Для других операций используются их обозначения.
В результате операции сложения возникает новый объект типа **Complex**.

Перегрузим присваивание:

```cpp
class Complex 
{
  ...
  Complex& operator=(const Complex& c) {
     Re=c.Re;
     Im=c.Im;
     return *this;
  }
  ...
};
```

Теперь можно воспользоваться двумя перегруженными операциями:

```cpp
Complex a(1.1,2.2),b(3.3,4.4),c(0.0,0.0);
c=a+b;
```

#### Унарные операции

Поскольку в операции участвует только один операнд, то никаких внешних ссылок методу, реализующему операцию, передавать не нужно.

```cpp
Complex operator- ()
{
   Complex temp;
   temp.Re=-Re;
   temp.Im=-Im;
   return temp;
}
```

Для операций ++ и -- таже существуют две формы: **префиксная** и **постфиксная**, которые реализуются при перегрузке особым образом.

Рассмотрим пример (класс Coord)

```cpp
class Coord {
   int x,y,z;
   public:
     Coord(int _x,int _y, int _z): x(_x),y(_y),z(_z) {}
     ...
     // Перегрузка префиксной формы:
     Coord& operator++() {
        ++x; ++y; ++z;
        return *this;
     }
     // Перегрузка постфиксной формы:
     Coord operator++(int) {
        Coord temp=*this;
        ++x; ++y; ++z;
        return temp;
     }
     ...
};
```

### Перегрузка внешней функцией

В этом случае у нас есть также две возможности: создать обычную функцию, или функцию, **дружественную** классу. В случае **унарной** операции функция должна принимать ссылку на объект класса, к которому она применяется. Если операция **бинарная**, то таких ссылок должно быть две: на первый аргумент и на второй.

Вот пример дружественной функции:

```cpp
Coord operator+(const Coord& c1, const Coord& c2) {
  Coord temp;
  temp.x=c1.x+c2.x;
  temp.y=c1.y+c2.y;
  temp.z=c1.z+c2.z;
  return temp;
}
```

Для образования дружественности нужно поместить прототип этой функции в класс **Coord** со словом **friend**.

Для обычной функции прямой доступ к закрытым полям невозможен, поэтому она использует публичные методы (геттеры).
